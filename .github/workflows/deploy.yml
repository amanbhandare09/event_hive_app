name: Deploy Event Hive Flask App

on:
  push:
    branches: ["main"]
  workflow_dispatch: # Allows manual triggering

env:
  DEPLOY_PATH: ~/event_hive_app
  TEMP_PATH: ~/event_hive_app_temp

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production # Optional: adds approval gates
    
    steps:
      # 1Ô∏è‚É£ Checkout repository
      - name: Checkout code
        uses: actions/checkout@v4

      # 2Ô∏è‚É£ Setup SSH key
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          
          # Always decode from base64
          echo "Decoding SSH key from base64..."
          echo "${{ secrets.EC2_SSH_KEY }}" | base64 -d > ~/.ssh/id_rsa
          
          chmod 600 ~/.ssh/id_rsa
          
          # Show file info for debugging
          echo "Key file size: $(wc -c < ~/.ssh/id_rsa) bytes"
          echo "First line: $(head -1 ~/.ssh/id_rsa)"
          echo "Last line: $(tail -1 ~/.ssh/id_rsa)"
          
          # Verify key format
          if ssh-keygen -l -f ~/.ssh/id_rsa 2>/dev/null; then
            echo "‚úÖ SSH key is valid"
          else
            echo "‚ùå SSH key validation failed"
            echo "This might be a key format issue"
            exit 1
          fi

      # 3Ô∏è‚É£ Add EC2 host to known hosts
      - name: Add EC2 to known hosts
        run: |
          chmod 600 ~/.ssh/id_rsa  # Ensure permissions before any SSH operation
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || {
            echo "Warning: Could not add host to known_hosts, will use StrictHostKeyChecking=no"
          }

      # 4Ô∏è‚É£ Debug and test connection
      - name: Debug connection details
        run: |
          echo "Verifying connection parameters..."
          echo "Username length: ${#EC2_USERNAME}"
          echo "Host length: ${#EC2_HOST}"
          
          # Test DNS resolution
          if [[ "$EC2_HOST" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚úì EC2_HOST appears to be an IP address"
          else
            echo "EC2_HOST appears to be a hostname, testing DNS..."
            nslookup "$EC2_HOST" || echo "‚ö†Ô∏è DNS lookup failed"
          fi
          
          # Test ping
          ping -c 2 "$EC2_HOST" || echo "‚ö†Ô∏è Ping failed (may be blocked by security group)"
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
      
      - name: Test SSH connection
        run: |
          echo "Attempting SSH connection..."
          ssh -T -i ~/.ssh/id_rsa \
            -o StrictHostKeyChecking=no \
            -o ConnectTimeout=10 \
            -o ServerAliveInterval=60 \
            "$EC2_USERNAME@$EC2_HOST" \
            "echo '‚úì SSH connection successful'" || {
              echo "‚ùå SSH connection failed"
              echo "Please check:"
              echo "1. EC2 instance is running"
              echo "2. Security group allows SSH from GitHub Actions IPs"
              echo "3. SSH key matches the one in EC2"
              exit 1
            }
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USERNAME: ${{ secrets.EC2_USERNAME }}

      # 5Ô∏è‚É£ Create deployment metadata
      - name: Create deployment info
        run: |
          cat > deployment_info.txt << EOF
          COMMIT_SHA=${{ github.sha }}
          COMMIT_MESSAGE=$(git log -1 --pretty=%B | head -n 1)
          DEPLOYED_AT=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          DEPLOYED_BY=${{ github.actor }}
          BRANCH=${{ github.ref_name }}
          WORKFLOW_RUN=${{ github.run_number }}
          EOF
          cat deployment_info.txt

      # 6Ô∏è‚É£ Prepare EC2 environment
      - name: Prepare EC2 environment
        run: |
          ssh -T -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no \
            "$EC2_USERNAME@$EC2_HOST" << 'EOF'
            set -e
            echo "Creating temporary deployment directory..."
            mkdir -p ${{ env.TEMP_PATH }}
            
            echo "Checking if app directory exists..."
            if [ -d "${{ env.DEPLOY_PATH }}" ]; then
              echo "‚úì Existing app directory found"
            else
              echo "Creating new app directory..."
              mkdir -p ${{ env.DEPLOY_PATH }}
            fi
          EOF
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USERNAME: ${{ secrets.EC2_USERNAME }}

      # 7Ô∏è‚É£ Upload project files to EC2
      - name: Upload project files
        run: |
          echo "Uploading files to EC2..."
          rsync -avz --delete \
            --exclude='.git' \
            --exclude='.github' \
            --exclude='__pycache__' \
            --exclude='*.pyc' \
            --exclude='*.pyo' \
            --exclude='.pytest_cache' \
            --exclude='.env.local' \
            --exclude='venv' \
            --exclude='node_modules' \
            --exclude='.DS_Store' \
            --exclude='*.log' \
            -e "ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no" \
            ./ \
            "$EC2_USERNAME@$EC2_HOST:${{ env.TEMP_PATH }}/"
          
          echo "‚úì Files uploaded successfully"
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USERNAME: ${{ secrets.EC2_USERNAME }}

      # 8Ô∏è‚É£ Run deploy script on EC2
      - name: Run deploy script
        run: |
          ssh -T -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no \
            "$EC2_USERNAME@$EC2_HOST" << 'EOF'
            set -e
            
            echo "Making deploy script executable..."
            chmod +x ${{ env.TEMP_PATH }}/deploy.sh
            
            echo "Running deployment script..."
            cd ${{ env.TEMP_PATH }}
            bash deploy.sh
            
            echo "‚úì Deployment script completed"
          EOF
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USERNAME: ${{ secrets.EC2_USERNAME }}

      # 9Ô∏è‚É£ Health check
      - name: Health check
        run: |
          echo "Waiting for application to start..."
          sleep 15
          
          echo "Performing health check..."
          MAX_RETRIES=5
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -f -s -o /dev/null -w "%{http_code}" "http://$EC2_HOST:5000/health" | grep -q "200"; then
              echo "‚úì Health check passed"
              exit 0
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "Health check attempt $RETRY_COUNT/$MAX_RETRIES failed, retrying..."
              sleep 5
            fi
          done
          
          echo "‚ö†Ô∏è Warning: Health check failed after $MAX_RETRIES attempts"
          echo "The application may still be starting up. Please verify manually."
          # Don't fail the workflow, just warn
          exit 0
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}

      # üîü Cleanup temp directory
      - name: Cleanup temporary files
        if: always()
        run: |
          ssh -T -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no \
            "$EC2_USERNAME@$EC2_HOST" \
            "rm -rf ${{ env.TEMP_PATH }}" || true
          
          echo "‚úì Cleanup completed"
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USERNAME: ${{ secrets.EC2_USERNAME }}

      # 1Ô∏è‚É£1Ô∏è‚É£ Deployment summary
      - name: Deployment summary
        if: success()
        run: |
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üéâ DEPLOYMENT SUCCESSFUL"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üì¶ Commit: ${{ github.sha }}"
          echo "üë§ Deployed by: ${{ github.actor }}"
          echo "üåø Branch: ${{ github.ref_name }}"
          echo "üîó Application URL: http://$EC2_HOST:5000"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}

      # 1Ô∏è‚É£2Ô∏è‚É£ Show error logs on failure
      - name: Show deployment errors
        if: failure()
        run: |
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚ùå DEPLOYMENT FAILED - Fetching error logs"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          
          chmod 600 ~/.ssh/id_rsa
          
          ssh -T -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no \
            "$EC2_USERNAME@$EC2_HOST" << 'EOF' || true
            echo "=== Service Status ==="
            sudo systemctl status eventhive --no-pager -l || true
            
            echo ""
            echo "=== Last 30 lines of service logs ==="
            sudo journalctl -u eventhive -n 30 --no-pager || true
            
            echo ""
            echo "=== Nginx Error Log ==="
            sudo tail -20 /var/log/nginx/event_hive_error.log 2>/dev/null || echo "No nginx logs found"
          EOF
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USERNAME: ${{ secrets.EC2_USERNAME }}

      # 1Ô∏è‚É£3Ô∏è‚É£ Rollback on failure
      - name: Rollback on failure
        if: failure()
        run: |
          echo "‚ùå Deployment failed, initiating rollback..."
          
          # Ensure SSH key has correct permissions
          chmod 600 ~/.ssh/id_rsa
          
          ssh -T -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no \
            "$EC2_USERNAME@$EC2_HOST" << 'EOF'
            set -e
            
            # Remove failed deployment
            rm -rf ${{ env.TEMP_PATH }}
            
            # Restart the service to use the previous version
            if [ -f "${{ env.DEPLOY_PATH }}/deploy.sh" ]; then
              cd ${{ env.DEPLOY_PATH }}
              bash deploy.sh || echo "Could not restart service"
            fi
            
            echo "‚ö†Ô∏è Rollback attempt completed"
          EOF
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
